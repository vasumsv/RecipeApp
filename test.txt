  @Test
    void getRetNetRowsForManualPaymentTest_DirtyCoverage() {
        List<InvoicePayableModelForPayment> paymentList = new ArrayList<>();
        InvoicePayableModelForPayment payment = new InvoicePayableModelForPayment();
        payment.setProviderId("provider1");
        payment.setProviderName("Provider One");
        InvoicePayable invoicePayable = new InvoicePayable();
        invoicePayable.setCode("INV123");
        payment.setInvoicePayable(invoicePayable);
        payment.setInvoiceReference("REF123");
        paymentList.add(payment);

        PaymentDates dates = new PaymentDates();
        dates.setSettlementDate("2023-01-01");

        List<Map<PayableModel, List<String>>> listMap = new ArrayList<>();
        Map<PayableModel, List<String>> map = new HashMap<>();
        map.put(new PayableModel(), Arrays.asList("portfolio1"));
        listMap.add(map);

        PortfolioAdvanceDetailsResponse portfolioDetails = new PortfolioAdvanceDetailsResponse();

        List<SettlementAccount> settlementAccounts = new ArrayList<>();
        settlementAccounts.add(new SettlementAccount());

        when(referentialServiceApi.getPaymentDates(anyString(), anyString(), anyString())).thenReturn(dates);
        when(invoiceServiceApi.getListOfBagDetailsForMultipleInvoices(anyList())).thenReturn(listMap);
        when(referentialServiceApi.getPortfolioDetailsBasedOnMnemonic(anyString())).thenReturn(portfolioDetails);
        when(referentialServiceApi.getSettlementAccounts(anyString(), anyString(), anyString())).thenReturn(settlementAccounts); // Corrected line

        Map<GroupingKey, BigDecimal> aggregateAmount = new ConcurrentHashMap<>();
        aggregateAmount.put(new GroupingKey("entity1", "USD"), new BigDecimal("200.00"));

        Map<GroupingKey, Integer> aggregateInvoiceCount = new ConcurrentHashMap<>();
        aggregateInvoiceCount.put(new GroupingKey("entity1", "USD"), 2);

        Map<GroupingKey, String> aggregateInvoiceReferences = new ConcurrentHashMap<>();
        aggregateInvoiceReferences.put(new GroupingKey("entity1", "USD"), "REF1|REF2|");

        // Directly set the maps for the loop using reflection (dirty but gets coverage)
        try {
            java.lang.reflect.Field amountField = CashAllocationDomain.class.getDeclaredField("aggregateAmount");
            amountField.setAccessible(true);
            amountField.set(cashAllocationDomain, aggregateAmount);

            java.lang.reflect.Field countField = CashAllocationDomain.class.getDeclaredField("aggregateInvoiceCount");
            countField.setAccessible(true);
            countField.set(cashAllocationDomain, aggregateInvoiceCount);

            java.lang.reflect.Field refField = CashAllocationDomain.class.getDeclaredField("aggregateInvoiceReferences");
            refField.setAccessible(true);
            refField.set(cashAllocationDomain, aggregateInvoiceReferences);

        } catch (NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
        }

        List<PaymentLinesModel> result = cashAllocationDomain.getRetNetRowsForManualPayment(paymentList, "user1");

        assertNotNull(result);
        assertEquals(1, result.size());
    }