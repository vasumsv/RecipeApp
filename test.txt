import io.cucumber.java.en.Given;
import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.http.*;
import org.springframework.security.test.context.support.WithMockUser;
import java.util.UUID;
import static org.junit.jupiter.api.Assertions.*;

public class InvoiceEditSteps {

    @Autowired
    private TestRestTemplate restTemplate;

    private UUID validUuid;
    private String invalidUuid;
    private String requestPayload;
    private ResponseEntity<ResponseMessage> response;
    private HttpStatus lastResponseStatus;

    // ========== Authentication Steps ========== //
    @Given("I am authenticated with the required scope")
    public void authenticateWithScope() {
        String validToken = "mocked-valid-token-with-scope:api_generate-and-send-invoices-to-clients.write";
        configureAuthorizationHeader(validToken);
    }

    @Given("I am authenticated with the {string} scope")
    public void authenticateWithOtherScope(String scope) {
        String otherToken = "mocked-token-with-scope:" + scope.replace("\"", "");
        configureAuthorizationHeader(otherToken);
    }

    @Given("I am not authenticated")
    public void unauthenticated() {
        restTemplate.getRestTemplate().getInterceptors().clear();
    }

    private void configureAuthorizationHeader(String token) {
        restTemplate.getRestTemplate().getInterceptors().clear();
        restTemplate.getRestTemplate().getInterceptors().add((request, body, execution) -> {
            request.getHeaders().add("Authorization", "Bearer " + token);
            return execution.execute(request, body);
        });
    }

    // ========== UUID Steps ========== //
    @Given("I have a valid UUID")
    public void validUuid() {
        this.validUuid = UUID.fromString("123e4567-e89b-12d3-a456-426614174000");
        this.invalidUuid = null;
    }

    @Given("I have an invalid UUID")
    public void invalidUuid() {
        this.validUuid = null;
        this.invalidUuid = "not-a-valid-uuid-format";
    }

    @Given("I have a non-existent UUID")
    public void nonExistentUuid() {
        this.validUuid = UUID.fromString("00000000-0000-0000-0000-000000000000");
        this.invalidUuid = null;
    }

    // ========== Payload Steps ========== //
    @Given("I have a valid InvoicePayableModel payload")
    public void validPayload() {
        this.requestPayload = """
            {
                "invoiceNumber": "INV-2023-001",
                "amount": 1000.50,
                "currency": "USD",
                "dueDate": "2023-12-31",
                "vendorDetails": {
                    "name": "Acme Corp",
                    "taxId": "TAX123456"
                },
                "lineItems": [
                    {
                        "description": "Consulting Services",
                        "quantity": 10,
                        "unitPrice": 100.05
                    }
                ]
            }
            """;
    }

    @Given("I have an invalid InvoicePayableModel payload")
    public void invalidPayload() {
        this.requestPayload = """
            {
                "invoiceNumber": "",
                "amount": -100,
                "currency": "XYZ",
                "dueDate": "2023-02-30",
                "vendorDetails": {}
            }
            """;
    }

    @Given("I have a payload with special characters")
    public void payloadWithSpecialChars() {
        this.requestPayload = """
            {
                "invoiceNumber": "INV-SPâ‚¬CIAL-001",
                "amount": 1000.50,
                "currency": "USD",
                "dueDate": "2023-12-31",
                "vendorDetails": {
                    "name": "Comp@ny & Co.",
                    "taxId": "TAX#123"
                }
            }
            """;
    }

    // ========== Request Steps ========== //
    @When("I send a PUT request to {string}")
    public void sendPutRequest(String endpoint) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("X-Request-ID", UUID.randomUUID().toString());

        String url = endpoint.replace("{wuid}", 
            validUuid != null ? validUuid.toString() : invalidUuid);

        HttpEntity<String> request = new HttpEntity<>(requestPayload, headers);
        try {
            response = restTemplate.exchange(
                url, 
                HttpMethod.PUT, 
                request, 
                ResponseMessage.class
            );
            lastResponseStatus = response.getStatusCode();
        } catch (Exception e) {
            lastResponseStatus = HttpStatus.INTERNAL_SERVER_ERROR;
        }
    }

    // ========== Verification Steps ========== //
    @Then("the response status should be {int}")
    public void assertStatus(int status) {
        assertEquals(status, lastResponseStatus.value());
    }

    @Then("the response contains a success message")
    public void assertSuccessMessage() {
        assertNotNull(response.getBody());
        assertEquals("Success", response.getBody().getMessage());
        assertNotNull(response.getBody().getTimestamp());
    }

    @Then("the response should include validation errors")
    public void assertValidationErrors() {
        assertNotNull(response.getBody());
        assertTrue(response.getBody().getErrors().size() > 0);
    }

    @Then("the response should indicate resource not found")
    public void assertResourceNotFound() {
        assertNotNull(response.getBody());
        assertEquals("Invoice not found", response.getBody().getMessage());
    }
}