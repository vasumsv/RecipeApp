 // Test skipped lines due to account numbers
    @Test
    void testSkipAccountNumbers() {
        List<String> lines = Arrays.asList(
            "X04501061855Y20231001...", // ACCOUNT_NUMBER_1
            "X20501444580Y20231001..."  // ACCOUNT_NUMBER_2
        );
        List<CashAllocationModel> result = cashAllocationDomain.cashAllocationModelList(
            lines, 
            "0815.WXG_BIFFACT" // Matches GAIA_WXG_FILE
        );
        assertTrue(result.isEmpty());
    }

    // Test exception handling in date parsing
    @Test
    void testDateParsingException() {
        List<String> lines = Collections.singletonList("INVALIDDATE 300038497 ...");
        List<CashAllocationModel> result = cashAllocationDomain.cashAllocationModelList(lines, "test.wxg");
        verify(logger).error("Exception Occurred", any(Exception.class));
    }

    // Test logger coverage for substring errors (amount parsing)
    @Test
    void testAmountParsingError() {
        List<String> lines = Collections.singletonList("SHORT_LINE");
        cashAllocationDomain.cashAllocationModelList(lines, "test.wxg");
        verify(logger).error("Exception Occurred", any(Exception.class));
    }

    // Test empty input
    @Test
    void testEmptyInput() {
        List<CashAllocationModel> result = cashAllocationDomain.cashAllocationModelList(
            Collections.emptyList(), 
            "test.wxg"
        );
        assertTrue(result.isEmpty());
    }

    // Test lines that trigger continue in loop
    @Test
    void testContinueInLoop() {
        List<String> lines = Arrays.asList(
            "X300038497Y20231001...", // GAIA_WXG_EZE_FILE account
            "INVALID_LINE"
        );
        List<CashAllocationModel> result = cashAllocationDomain.cashAllocationModelList(
            lines, 
            "0815.WXG_EZE" // Matches GAIA_WXG_EZE_FILE
        );
        assertTrue(result.isEmpty());
    }