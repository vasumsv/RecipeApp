    @Test
    void getRetNetRowsForManualPaymentTest() {
        // Setup mock data
        List<InvoicePayableModelForPayment> paymentList = new ArrayList<>();
        InvoicePayableModelForPayment payment = new InvoicePayableModelForPayment();
        payment.setProviderId("provider1");
        payment.setProviderName("Provider One");
        InvoicePayable invoicePayable = new InvoicePayable();
        invoicePayable.setCode("INV123");
        invoicePayable.setInvoiceType("RET"); // Set InvoiceType to avoid NPE
        payment.setInvoicePayable(invoicePayable);
        payment.setInvoiceReference("REF123");
        paymentList.add(payment);

        PaymentDates dates = new PaymentDates();
        dates.setSettlementDate("2023-01-01");

        List<Map<PayableModel, List<String>>> listMap = new ArrayList<>();
        Map<PayableModel, List<String>> map = new HashMap<>();
        map.put(new PayableModel(), Arrays.asList("portfolio1"));
        listMap.add(map);

        PortfolioAdvanceDetailsResponse portfolioDetails = new PortfolioAdvanceDetailsResponse();

        List<SettlementAccount> settlementAccounts = new ArrayList<>();
        settlementAccounts.add(new SettlementAccount());
        settlementAccounts.add(new SettlementAccount());

        // Mock service calls
        when(referentialServiceApi.getPaymentDates(anyString(), anyString(), anyString())).thenReturn(dates);
        when(invoiceServiceApi.getListOfBagDetailsForMultipleInvoices(anyList())).thenReturn(listMap);
        when(referentialServiceApi.getPortfolioDetailsBasedOnMnemonic(anyString())).thenReturn(portfolioDetails);
        when(referentialServiceApi.getSettlementAccounts(anyString(), anyString(), anyString())).thenReturn(settlementAccounts);

        // Prepare the input that will lead to the loop execution
        Map<GroupingKey, BigDecimal> aggregateAmount = new ConcurrentHashMap<>();
        aggregateAmount.put(new GroupingKey("entity1", "USD"), new BigDecimal("200.00"));

        Map<GroupingKey, Integer> aggregateInvoiceCount = new ConcurrentHashMap<>();
        aggregateInvoiceCount.put(new GroupingKey("entity1", "USD"), 2);

        Map<GroupingKey, String> aggregateInvoiceReferences = new ConcurrentHashMap<>();
        aggregateInvoiceReferences.put(new GroupingKey("entity1", "USD"), "REF1|REF2|");

        // Call the method
        List<PaymentLinesModel> result = cashAllocationDomain.getRetNetRowsForManualPayment(paymentList, "user1");

        // Assertions
        assertNotNull(result);
        assertEquals(1, result.size());
        assertEquals("entity1", result.get(0).getEntity());
        assertEquals("+", result.get(0).getPaymentDirection()); // Based on the BigDecimal("200.00")
        assertEquals("INV123", result.get(0).getInvoiceReference());
        assertEquals(2, result.get(0).getNumberOfInvoices());
        assertEquals(2, result.get(0).getSettlementAccounts().size());
        assertEquals("RET", result.get(0).getFeeType()); // Based on substring of InvoiceReference
        assertEquals("NULL", result.get(0).getPaymentMode());
        assertEquals("Y", result.get(0).getPaymentStatus());

        // To cover the other branch of payment direction:
        aggregateAmount.clear();
        aggregateAmount.put(new GroupingKey("entity2", "EUR"), new BigDecimal("-50.00"));
        aggregateInvoiceCount.clear();
        aggregateInvoiceCount.put(new GroupingKey("entity2", "EUR"), 1);
        aggregateInvoiceReferences.clear();
        aggregateInvoiceReferences.put(new GroupingKey("entity2", "EUR"), "REF3|");
        paymentList.get(0).getInvoicePayable().setCode("INV456");
        paymentList.get(0).setInvoiceReference("OTHER"); // Fee type might change

        List<PaymentLinesModel> resultNegative = cashAllocationDomain.getRetNetRowsForManualPayment(paymentList, "user2");
        assertNotNull(resultNegative);
        assertEquals(1, resultNegative.size());
        assertEquals("entity2", resultNegative.get(0).getEntity());
        assertEquals("-", resultNegative.get(0).getPaymentDirection());
        assertEquals("INV456", resultNegative.get(0).getInvoiceReference());
        assertEquals(1, resultNegative.get(0).getNumberOfInvoices());
    }