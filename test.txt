import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.math.BigDecimal;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class CashAllocationDomainTest {

    @Mock
    private ReferentialServiceApi referentialServiceApi;

    @Mock
    private InvoiceServiceApi invoiceServiceApi;

    @InjectMocks
    private CashAllocationDomain cashAllocationDomain;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void getRetNetRowsForManualPaymentTest() {
        // Setup mock data
        List<InvoicePayableModelForPayment> paymentList = new ArrayList<>();
        InvoicePayableModelForPayment payment = new InvoicePayableModelForPayment();
        payment.setProviderId("provider1");
        payment.setProviderName("Provider One");
        payment.setInvoicePayable(new InvoicePayable());
        payment.getInvoicePayable().setCode("INV123");
        payment.setInvoiceReference("REF123");
        paymentList.add(payment);

        PaymentDates dates = new PaymentDates();
        dates.setSettlementDate("2023-01-01");

        List<Map<PayableModel, List<String>>> listMap = new ArrayList<>();
        Map<PayableModel, List<String>> map = new HashMap<>();
        map.put(new PayableModel(), Arrays.asList("portfolio1", "portfolio2"));
        listMap.add(map);

        PortfolioAdvanceDetailsResponse portfolioDetails = new PortfolioAdvanceDetailsResponse();

        List<SettlementAccount> settlementAccounts = new ArrayList<>();
        settlementAccounts.add(new SettlementAccount());

        // Mock method calls
        when(referentialServiceApi.getPaymentDates(anyString(), anyString(), anyString())).thenReturn(dates);
        when(invoiceServiceApi.getListOfBagDetailsForMultipleInvoices(anyList())).thenReturn(listMap);
        when(referentialServiceApi.getPortfolioDetailsBasedOnMnemonic(anyString())).thenReturn(portfolioDetails);
        when(referentialServiceApi.getSettlementAccounts(anyString(), anyString(), anyString())).thenReturn(settlementAccounts);

        // Prepare grouping key and aggregate amount
        GroupingKey groupingKey = new GroupingKey("entity1", "USD");
        Map<GroupingKey, BigDecimal> aggregateAmount = new ConcurrentHashMap<>();
        aggregateAmount.put(groupingKey, new BigDecimal("200.00"));

        Map<GroupingKey, Integer> aggregateInvoiceCount = new ConcurrentHashMap<>();
        aggregateInvoiceCount.put(groupingKey, 2);

        Map<GroupingKey, String> aggregateInvoiceReferences = new ConcurrentHashMap<>();
        aggregateInvoiceReferences.put(groupingKey, "REF1|REF2|");

        // Set up the entry set for the loop
        Set<Map.Entry<GroupingKey, BigDecimal>> entrySet = aggregateAmount.entrySet();
        Iterator<Map.Entry<GroupingKey, BigDecimal>> iterator = entrySet.iterator();
        Map.Entry<GroupingKey, BigDecimal> entry = iterator.next();

        // Use reflection to set the fields in the CashAllocationDomain instance
        try {
            java.lang.reflect.Field aggregateAmountField = CashAllocationDomain.class.getDeclaredField("aggregateAmount");
            aggregateAmountField.setAccessible(true);
            aggregateAmountField.set(cashAllocationDomain, aggregateAmount);

            java.lang.reflect.Field aggregateInvoiceCountField = CashAllocationDomain.class.getDeclaredField("aggregateInvoiceCount");
            aggregateInvoiceCountField.setAccessible(true);
            aggregateInvoiceCountField.set(cashAllocationDomain, aggregateInvoiceCount);

            java.lang.reflect.Field aggregateInvoiceReferencesField = CashAllocationDomain.class.getDeclaredField("aggregateInvoiceReferences");
            aggregateInvoiceReferencesField.setAccessible(true);
            aggregateInvoiceReferencesField.set(cashAllocationDomain, aggregateInvoiceReferences);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
        }

        // Call the method
        List<PaymentLinesModel> result = cashAllocationDomain.getRetNetRowsForManualPayment(paymentList, "user1");

        // Assertions
        assertNotNull(result);
        assertEquals(1, result.size());
        assertEquals("entity1", result.get(0).getEntity());
    }
}