sql:
  baseUrl2: "https://api.yourservice.com"
  register: "/api/invoices"
  edit: "/api/invoices/{uuid}"  # Using placeholder
  # OR
  edit: "/api/invoices/"   


  // Add this to your class fields
private String editInvoiceUrl; // Will store the edit endpoint

// Modify your constructor to load the edit endpoint from config
public RegisterInvoiceForPayableSteps() throws IOException {
    String environmentType = System.getProperty("environment-type");
    try (InputStream inputStream = this.getClass().getClassLoader()
        .getResourceAsStream("application-" + environmentType + ".yml")) {
        Yaml yaml = new Yaml();
        Map<String, Object> data = yaml.load(inputStream);
        Map<String,String> sgConfig = (Map<String,String>) data.get("sql");
        this.baseUrl2 = sgConfig.get("baseUrl2");
        this.registerEndpoint = sgConfig.get("register");
        this.editInvoiceUrl = sgConfig.get("edit"); // Load edit endpoint from config
    }
}

// Modified edit method with URL handling
@When("I send a PUT request to edit invoice")
public void iSendPutRequestToEditInvoice() throws IOException {
    // Get the created invoice reference
    String invoiceReference = responseEntity.getBody().getInvoiceReference();
    
    // Construct edit URL - two possible approaches:
    
    // APPROACH 1: If endpoint has placeholder
    String url = baseUrl2 + editInvoiceUrl.replace("{uuid}", invoiceReference);
    
    // APPROACH 2: If endpoint is just a path
    // String url = baseUrl2 + editInvoiceUrl + "/" + invoiceReference;
    
    // Use the creation response as base
    InvoicePayableModel editPayload = responseEntity.getBody();
    
    // Make minimal changes
    editPayload.setInvoiceStatus("EDITED");
    
    HttpEntity<InvoicePayableModel> requestEntity = 
        new HttpEntity<>(editPayload, headers);
    
    editResponseEntity = restTemplate.exchange(
        url,
        HttpMethod.PUT, 
        requestEntity,
        InvoicePayableModel.class
    );
}


